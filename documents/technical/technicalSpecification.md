# Technical Specification Document | Team 4

--- 
 
<details>
<summary>Table of Content</summary>

- [Technical Specification Document | Team 4](#technical-specification-document--team-4)
  - [Introduction](#introduction)
    - [Overview](#overview)
    - [Disclaimer](#disclaimer)
    - [Content](#content)
  - [Architecture](#architecture)
    - [Technicalities](#technicalities)
    - [Naming Conventions](#naming-conventions)
    - [File Organisation](#file-organisation)
    - [Endians](#endians)
    - [CISC/RISC](#ciscrisc)
    - [Principles](#principles)
      - [Libraries](#libraries)
      - [Comments](#comments)
    - [Virtual Terminal](#virtual-terminal)
  - [Compiler](#compiler)
    - [Step 1 Lexical Analysis](#step-1-lexical-analysis)
    - [Step 2 Syntax Analysis](#step-2-syntax-analysis)
    - [Step 3 Code Generation](#step-3-code-generation)
    - [Error Handling](#error-handling)
    - [Diagram](#diagram)
  - [Interpreter](#interpreter)
    - [Step 1 Tokenization](#step-1-tokenization)
    - [Step 2 Parsing](#step-2-parsing)
    - [Step 3 Interpreter Core](#step-3-interpreter-core)
    - [Error Handling](#error-handling-1)
    - [Diagrams](#diagrams)
  - [Glossary and Functions](#glossary-and-functions)
    - [Glossary](#glossary)
    - [Functions](#functions)

</details>

---

## Introduction

### Overview

This document is the technical specification of a project commissioned to us by ALGOSUP. The project consist in creating a virtual processor and it's component.

### Disclaimer

This document will not describe the assembly language and it's working, those information will be available in the [functional specification](/documents/functional/functionalSpecification.md).

### Content

This document will contain the details of the compiler, the details of the interpreter, the architecture of the project as well as some pseudo code exemple of some importante function.

---

## Architecture

### Technicalities

The program will be develloped in C(no matter the version), with the GCC compiler. It will be develloped on Windows and Linux, but must support any other OS.

### Naming Conventions

```
GitHub branches: kebab-case
const: ALL_CAPS
variables: camelCase
functions: snake_case
struct/typedef: camelCase
macros: ALL_CAPS
file: snake_case
enum: PascalCase
enum member: ALL_CAPS
```

### File Organisation
```
src-----
        main.c
        lib------
                interpret.h
                file.h
                utils.h
                errors.h
----------------
```

- interpret.h will handle the interpretert of the program,
- file.h will handle the lexical analysis of the compiler,
- utils.h
- errors.h will handle all the errors,

### Endians

The program will use little endians, for it is advantageous in processor architecture and we preshot using our program on a real processor and not a virtual one.

### CISC/RISC

The program will based itself on the RISC, as a RISC architecture provides less inctruction, which in turn allow us to reduce th complexity of the program.

### Principles

#### Libraries

The only libraries allowed are the [C standard Libraries](https://en.cppreference.com/w/c/header).

#### Comments

Each functions and process are to be explained with comments.

### Virtual Terminal

The Virtual Terminal is a part of the vitual processor; it will be used to display the inputs and outputs of the program, such as the name of the file the user wish to use.

--- 

## Compiler

### Step 1 Lexical Analysis

Scan the input code and break it down into tokens such as instructions, registers, and operands.
Can be called a Lexer and is represented in the project as [```lexen_file```](#functions).

### Step 2 Syntax Analysis

Analyse(= Parse) the code based on the tokens generated by the lexer. We input the result of the parsing in ```struct instruction```, the struct is then checked to see if any values are undefined and if they are throw an error.
This step is represented as the functions [``` parse_instruction```](#functions).

### Step 3 Code Generation

Translate the assembly code into machine code instructions. Each assembly instruction corresponds to one machine code instructions.

### Error Handling

Detect and report errors in the assembly code and inform the users of the errors.

### Diagram

Here is a visual representation of how the compiler works:

[Compiler Diagram](/documents/.data/pictures/compilerDiagram.png)

---
TODO: refactor this part entirely
## Interpreter

### Step 1 Tokenization

Go through the machine code and break it down into token

### Step 2 Parsing

Analyse the code based on the tokens generated by the lexer. We input the result of the parsing in ```struct instruction```.
This step is represented as the functions [``` parse_instruction```](#functions).

### Step 3 Interpreter Core

The logic that go through the AST and interpret the statements, evaluate the expressions and handle the control flow.
The Core is composed of 3 functions in our project[```Ã¬nterpret_instruction```](#functions)and [```execute_function```](#functions).

### Error Handling

### Diagrams

Here is a visual representaion of how the intepreter works:

---

## Glossary and Functions

### Glossary

- virtual processor: 

- compiler:

- interpreter:

- assembly code: is the closest language to the machine that humans can understand and write in,

- keyword: words that have a specials meaning and are recognized by the compiler/interpreter,

- identifier: is a symbol/lexical token that names the language entities(i.e. variables, data types),

- instruction: is an order given to the computer processor by a computer program,

- logic: is a set of principles that delineates how elements should be arranged so a computer can perform specific tasks,

- stack: is an abstract data type that serves as a collection of elements with two main operations: push and pop,

- semantic: is a description of the process a computer follows when executing a computer program in a specific language

- debugging: is the process of finding and fixing mistakes in a the source code of any software.

### Functions

(This will probably get yeeted out)

Here you will find a pseudo code example of the functions named in the document(these example are not complete functions and are not to be taken as face value).


- lexen_file:
```
function lexen_file(file)
{
line   integer
token  integer
c       character

loop:
    read a character into c
    if c is a blank or a tab then
      do nothing

    else if c is a new line then
      nLine += 1

    else if c is a digit then
      create a token of this digit and the following
      return nToken
    [...]
}
```
- parse_instruction:
```
function parse_instruction(tokens)
{
  if token is null then
    return no more token

  else if token is an integer then
    return instruction(type integer, val1 = value, val2 = value, line = numero de ligne du fichier)
    // create a new object in the struct instruction
  [...] // all the other type of instruction
  else if no case match
  throw syntax_error("Unexpected token " + token)
}
```
- interpret_instruction: 
```
function interpret_expression(instruction, env)
{
  // go throught all the instruction type 
  switch instruction type:
    case int:
      int_(instruction)
      break
  [...]
  default break
}
```
- execute_function:
```
function execute_function(functionName, arguments):
    switch functionName:
        case "add":
            return executeAddFunction(arguments)

        [...]

        default:
            throw RuntimeError("Function '" + functionName + "' not found")

function executeAddFunction(arguments):
    if length(arguments) != 2:
        throw RuntimeError("Function 'add' expects 2 arguments")

    arg1 = interpretExpression(arguments[0])
    arg2 = interpretExpression(arguments[1])

    if arg1.type == INT and arg2.type == INT:
        return createValue(INT, arg1.data + arg2.data)
    else if arg1.type == FLOAT or arg2.type == FLOAT:
        return createValue(FLOAT, arg1.data + arg2.data)
    else:
        throw RuntimeError("Invalid types for addition")
[...]
```