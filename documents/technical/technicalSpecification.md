# Technical Specification Document | Team 4

--- 

<details>
<summary>Table of Content</summary>

- [Technical Specification Document | Team 4](#technical-specification-document--team-4)
  - [Introduction](#introduction)
    - [Overview](#overview)
    - [Disclaimer](#disclaimer)
  - [Architecture](#architecture)
    - [Naming Conventions](#naming-conventions)
    - [File Organisation](#file-organisation)
  - [Interpreter](#interpreter)
    - [Step 1 Tokenization](#step-1-tokenization)
    - [Step 2 Parsing](#step-2-parsing)
    - [Step 3 AST Nodes](#step-3-ast-nodes)
    - [Step 4 Interpreter Core](#step-4-interpreter-core)
    - [Step 5 Execution Stack](#step-5-execution-stack)
    - [Step 6 Error Handling](#step-6-error-handling)
  - [Glossary and Functions](#glossary-and-functions)
    - [Glossary](#glossary)
    - [Functions](#functions)

</details>

---

## Introduction

### Overview

This document is the technical specification of a project commissioned to us by ALGOSUP. The project consist in creating a virtual processor and an interpretor for running assembly code on that processor.

### Disclaimer

This document will not describe the assembly language and it's working, those information will be available in the [functional specification](/documents/functional/functionalSpecification.md).

---

## Architecture

### Naming Conventions

```
const: ALL_CAPS
variables: camelCase
functions: snake_case
struct/typedef: camelCase
macros: ALL_CAPS
file: snake_case
enum: PascalCase
enum member: ALL_CAPS
```

### File Organisation
```
src-----
        main.c
        lib------
                interpret.h
                file.h
                utils.h
----------------
```

interpret.h will contain the functions relative to the interpreter.
file.h will contain the functions relative to the file handling.
utils.h will contain some miscellianous function.

---

## Interpreter

### Step 1 Tokenization

Scan the input code and break it down into token, token that represent a basic unit of the language such as keywords or identifiers.
Can be called a Lexer and is represented in the project as [```lexen_file```](#functions).

### Step 2 Parsing

Analyse the code based on the tokens generated by the lexer. This step produce an Abstract Syntax Tree(AST) that represent the structure of the input code.
This step is represented as the functions [``` parse_statement```](#functions) and [```parse_expression```](#functions).

### Step 3 AST Nodes

Define structures or classes for different types of nodes in the AST. Each node corresponds to a specific language construct, such as expressions, statements, and declarations. We use the function [```create_AST_node```](#functions).

### Step 4 Interpreter Core

The logic that go through the AST and interpret the statements, evaluate the expressions and handle the control flow.
The Core is composed of 3 functions in our project[```ìnterpret_statement```](#functions),[```interpret_expression```](#functions) and [```execute_function```](#functions).

### Step 5 Execution Stack

The Execution Stack manage the call frames during the execution of functions, recursion and maintain the execution context. We manage the execution stack with ```ìnti_execution_stack```, ```push_frame``` and ```pop_frame```.

### Step 6 Error Handling

Syntax error, runtime error and semantics error are to be handled and error message are to be explicit to aid in the debugging.

---

## Glossary and Functions

### Glossary

- virtual processor: 
- interpreter:
- assembly code:
- keyword:
- identifiers:
- Abstract Syntax Tree:
- expression:
- statement:
- declaration:
- logic:
- stack:
- call frames:
- semantic:
- debugging:

### Functions

Here you will find a pseudo code example of the functions named in the document(these example are not complete functions and are not to be taken as face value).


- lexen_file:
```
function lexen_file(file)
{
nLine   integer
nToken  integer
c       character

loop:
    read a character into c
    if c is a blank or a tab then
      do nothing

    else if c is a new line then
      nLine += 1

    else if c is a digit then
      create a token of this digit and the following
      return nToken
    [...]
}
```
- parse_expression:
```
function parse_expression(tokens)
{
  if token is null then
    return no more token

  else if token is an integer then
    return create_AST_node(integer, value = current token value)
  [...]
  else if no case match
  throw syntax_error("Unexpected token " + token)
}
```
- parse_statement:
```
function parse_statement(tokens)
{
  if token is null then
    return no more token

  else if token is an identifier
    variableName = curent token value
    get the next token
    
    if next token is an assignment operator
      expression = parse_expression(tokens)
      return create_AST_node(assignment, variable = variableName, expression = expression)

    [...]

    else if no case match 
  throw syntax_error("Unexpected token " + token)
}
```
- create_AST_node:
```
function create_AST_node(type,...)
{
  node = {
    "type": type,
    [...]
  }

  switch type:
    case integer:
      node value = arguments[0]
      break

    case assignement statement:
      node variable = arguments[0]
      node expression = arguments[1]

    [...]
  return node
}
```
- interpret_expression: 
```
function interpret_expression(node, env)
{
  switch node type:
    case variable:
      variableName = node variable
      if variableName is in the environment
        return env[variableName]
      else
        throw runtime_error("Variable '" + variableName + "' not found")
      break
  [...]
}
```
- interpret_statement: 
```
function interpret_statement(node, env)
{
  switch node type:
    case assignment statement:
      variableName = node variable
      expressionValue = interpret_expression(node expression, env)

      env[variableName] = expressionValue
      break

    [...]

    default:
      throw runtime_error("Invalid statement node type)
}
```
- execute_function:
```
function execute_function(functionName, arguments):
    switch functionName:
        case "add":
            return executeAddFunction(arguments)

        [...]

        default:
            throw RuntimeError("Function '" + functionName + "' not found")

function executeAddFunction(arguments):
    if length(arguments) != 2:
        throw RuntimeError("Function 'add' expects 2 arguments")

    arg1 = interpretExpression(arguments[0])
    arg2 = interpretExpression(arguments[1])

    if arg1.type == INT and arg2.type == INT:
        return createValue(INT, arg1.data + arg2.data)
    else if arg1.type == FLOAT or arg2.type == FLOAT:
        return createValue(FLOAT, arg1.data + arg2.data)
    else:
        throw RuntimeError("Invalid types for addition")
[...]
```
- init_execution_stack:
```
function init_execution_stack(stack):
    stack.frames = []
    stack.size = 0 
    stack.capacity = 0 

```
- push_frame:
```
function push_frame(stack, functionNode, localEnv):
    if stack.size == stack.capacity:
        stack.capacity = (stack.capacity == 0) ? 1 : stack.capacity * 2
        stack.frames.resize(stack.capacity)

    // Push a new frame onto the stack
    stack.frames[stack.size].function = functionNode
    stack.frames[stack.size].localEnv = localEnv
    stack.size += 1
```
- pop_frame:
```
function pop_frame(stack):
    if stack.size > 0:
        stack.size = stack.size - 1
    else:
        throw RuntimeError("Attempted to pop an empty execution stack")

```